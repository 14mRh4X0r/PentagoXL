/* Generated by Together */
package pentagoxl;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.Socket;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.logging.Level;
import java.util.logging.Logger;
import pentagoxl.server.Server;

/**
 * Class which handles sending and receiving messages between server and client
 *
 */
public class NetHandler {

    private Socket socket;
    private Sender mySender;
    private List<Listener> listeners;

    /**
     * Creates a new <tt>NetHandler</tt> which uses <tt>sock</tt> to communicate with a server
     * @param sock <tt>Socket</tt> to use to communicate with a server
     * @require sock != null
     * @throws IOException
     * @ensure this.getSocket() == sock
     */
    public NetHandler(Socket sock) throws IOException {
        this.socket = sock;
        mySender = new Sender();
        mySender.start();
        new Processor().start();
        listeners = new ArrayList<Listener>();
    }

    private class Sender extends Thread {

        private ConcurrentLinkedQueue<String> queue = new ConcurrentLinkedQueue<String>();
        private PrintWriter writer;

        private Sender() throws IOException {
            writer = new PrintWriter(socket.getOutputStream(), true);
        }

        @Override
        public synchronized void run() {
            while (!socket.isOutputShutdown()) {
                while (!queue.isEmpty() && !socket.isOutputShutdown()) {
                    String toSend = queue.poll();
                    logMessage(toSend, false); // DEBUG
                    writer.println(toSend);
                }
                try {
                    this.wait();
                } catch (InterruptedException e) {
                    // We don't care.
                }
            }
        }

        public void addMessageToQueue(String msg) {
            queue.add(msg);
            synchronized (this) {
                this.notifyAll();
            }
        }
    }

    private class Processor extends Thread {

        private BufferedReader reader;

        public Processor() throws IOException {
            this.reader = new BufferedReader(new InputStreamReader(socket.getInputStream()), 1035);
        }

        public void run() {
            boolean stop = false;
            while (!socket.isClosed() && !socket.isInputShutdown() && !stop)
                try {
                    String in = reader.readLine();
                    logMessage(in, true);
                    if (in == null || in.matches("\\Q" + ProtocolEndpoint.DELIMITER + "\\E+"))
                        stop = true; // LOLHAI
                    else {
                        String[] cmdargs = ProtocolEndpoint.DELIMITER_PATTERN.split(in);
                        String cmd = cmdargs[0];
                        String[] args = null;
                        if (cmdargs.length > 1) {
                            args = new String[cmdargs.length - 1];
                            for (int i = 1; i < cmdargs.length; i++)
                                args[i - 1] = cmdargs[i];
                        }
                        synchronized (this) {
                            for (Listener l : NetHandler.this.listeners)
                                l.onReceive(cmd, args);
                        }
                    }
                } catch (OutOfMemoryError e) {
                    Server.logMessage(socket.getInetAddress() + " filled our buffer, disconnecting");
                    stop = true;
                } catch (IOException e) {
                    Logger.getLogger(this.getClass().getName()).log(Level.SEVERE, null, e);
                }
            if (!socket.isClosed())
                try {
                    socket.close();
                } catch (IOException e) {
                    // dafuq
                }
        }
    }

    /**
     * Listener interface for <tt>NetHandler</tt> <br>
     * Contains a method to use in a MVC-environment
     *
     */
    public static interface Listener {

    	/**
    	 * This is called when a message from the server is received. <br>
    	 * @param cmd Command received
    	 * @param args Arguments received
    	 */
        public void onReceive(String cmd, String[] args);
    }

    /**
     * Sends a message over the socket.
     * @param cmd Command to send
     * @param args arguments to send with the command
     * @see ProtocolEndpoint
     */
    public void addMessage(String cmd, String... args) {
        String message = cmd;
        for (String s : args) {
            message += pentagoxl.ProtocolEndpoint.DELIMITER;
            message += s;
        }

        mySender.addMessageToQueue(message);
    }

    /**
     * Builds a nack message. <br /> Will call
     * {@link #addMessage(java.lang.String, java.lang.String[]) }
     *
     * @param error <tt>Error to send</tt>
     */
    public void addNack(ProtocolError error) {
        addMessage(ProtocolEndpoint.SRV_NACK, error.getCode() + "");
    }

    /**
     * Adds a <tt>Listener</tt> to this observer
     * @param l Listener to be added
     */
    public synchronized void addListener(Listener l) {
        listeners.add(l);
    }

    /**
     * removes a <tt>Listener</tt> from this observer 
     * @param l Listener to be removed
     */
    public synchronized void removeListener(Listener l) {
        listeners.remove(l);
    }

    /**
     * Returns the socket this <tt>NetHander</tt> is using to communicate.
     *
     * @return A socket object
     */
    public Socket getSocket() {
        return socket;
    }

    private void logMessage(String msg, boolean incoming) {
        String naam = getSocket().getInetAddress().toString();
        String toPrint = naam + (incoming ? " > " : " < ") + msg;
        Server.logMessage(toPrint);
    }
}
