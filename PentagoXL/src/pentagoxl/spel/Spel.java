/* Generated by Together */
package pentagoxl.spel;

import java.util.ArrayList;
import java.util.List;
import java.util.Observable;
import pentagoxl.Client;
import pentagoxl.ProtocolEndpoint;

public class Spel extends Observable {

    private Bord bord;
    private List<Client> clients;
    private int zetIsAan;
    private boolean iemandKicked = false;

    public Spel() {
        bord = new Bord();
        zetIsAan = 0;
        clients = new ArrayList<Client>();
    }

    /**
     * Returns the <tt>Bord</tt> of this Spel.
     *
     * @return
     */
    public Bord getBord() {
        return bord;
    }

    /**
     * Returns a list of clients connec
     *
     * @return
     */
    public List<Client> getClients() {
        return clients;
    }

    public void addClient(Client client) {
        this.clients.add(client);
    }

    public void doeMove(int plek) {
        Client aanDeBeurt = clients.get(zetIsAan);
    	aanDeBeurt.canMove = false;
    	aanDeBeurt.aantalKnikkers -= 1;
    	aanDeBeurt.canRotate = true;
    	if (isOver()) {
    		broadCastWinnaars();
    	}
    }

    /**
     * Rotates one of the fields. <BR /> The fields are numbered: <BR /><tt> 1 |
     * 2 | 3 <BR /> 4 | 5 | 6 <BR /> 7 | 8 | 9 <BR /></tt> Negativeness is used
     * to rotate CCW.
     *
     * @param rotate Field to rotate
     */
    public void doeRotate(int rotate) {
        Client aanDeBeurt = clients.get(zetIsAan);
        aanDeBeurt.canRotate = false;
        nextPlayer();
        int hok = rotate * Integer.signum(rotate) - 1;
        boolean klokmee = Integer.signum(rotate) == 1;
        bord.getHok(hok).draai(klokmee);
        if (!isOver() || bord.getWinnaars().length == 0) {
        	speel();
        } else {
        	broadCastWinnaars();
        }
    }

    /**
     * Kicks the given client
     *
     * @param client
     */
    public void kickClient(Client client) {
        clients.remove(client);
        String[] clientNames = new String[clients.size()];
        for (int i = 0; i < clientNames.length; i++) {
        	clientNames[i] = clients.get(i).getNaam();
        }
        this.broadcast(ProtocolEndpoint.BCST_GAMEOVER, clientNames);
        for (Client c : this.getClients())
            c.setSpel(null);
    }

    private void speel() {
        Client aanDeBeurt = clients.get(zetIsAan);
        aanDeBeurt.canMove = true;
        broadcast(ProtocolEndpoint.BCST_TURN, aanDeBeurt.getNaam());
    }

    public void broadcast(String cmd, String... args) {
        for (Client c : clients)
            c.HANDLER.addMessage(cmd, args);
    }

    public boolean zetIsAanClient(Client client) {
        return clients.get(zetIsAan) == client;
    }

    public boolean isOver() {
        int alleKnikkers = 0;
        for (Client c : clients)
            alleKnikkers += c.aantalKnikkers;
        System.err.println(alleKnikkers);
        return alleKnikkers == 0 || bord.heeftWinnaar() || iemandKicked;
    }

    private String[] getPlayerNames() {
        String[] toRet = new String[clients.size()];
        for (int i = 0; i < toRet.length; i++)
            toRet[i] = clients.get(i).getNaam();

        return toRet;
    }

    /**
     * Starts the game.
     */
    public void start() {
        this.new Runner().start();
    }

    private class Runner extends Thread {

        @Override
        public void run() {
            int aantalKnikkers = clients.size() == 2 ? 40 : 20;
            for (int i = 0; i < clients.size(); i++) {
                Client c = clients.get(i);
                c.aantalKnikkers = aantalKnikkers;
                c.setVeld(Veld.byIndex(i));
            }

            broadcast(ProtocolEndpoint.BCST_STARTGAME, getPlayerNames());

            
            speel();
        }
    }
    
    private void broadCastWinnaars() {
        Speler[] winnaars = iemandKicked ? ((Client[]) clients.toArray()) : bord.getWinnaars();
        String[] winString = new String[winnaars.length];
        if (bord.heeftWinnaar()) {
            for (int i = 0; i < winnaars.length; i++)
                winString[i] = winnaars[i].getNaam();
        }
        broadcast(ProtocolEndpoint.BCST_GAMEOVER, winString);
    }
    
    private void nextPlayer() {
    	zetIsAan += 1;
    	zetIsAan %= clients.size();
    }
}
