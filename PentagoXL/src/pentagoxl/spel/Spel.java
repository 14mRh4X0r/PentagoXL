/* Generated by Together */
package pentagoxl.spel;

import java.util.List;
import java.util.Observable;
import pentagoxl.Client;
import pentagoxl.ProtocolEndpoint;

public class Spel extends Observable {

    private Bord bord;
    private List<Client> clients;
    private int zetIsAan;

    public Spel() {
        bord = new Bord();
        zetIsAan = 0;
    }

    /**
     * Returns the <tt>Bord</tt> of this Spel.
     *
     * @return
     */
    public Bord getBord() {
        return bord;
    }

    /**
     * Returns a list of clients connec
     *
     * @return
     */
    public List<Client> getClients() {
        return clients;
    }

    public void addClient(Client client) {
        this.clients.add(client);
    }

    private void doeMove(int plek) {
    }

    /**
     * Rotates one of the fields. <BR /> The fields are numbered: <BR /><tt> 1 |
     * 2 | 3 <BR /> 4 | 5 | 6 <BR /> 7 | 8 | 9 <BR /></tt> Negativeness is used
     * to rotate CCW.
     *
     * @param rotate Field to rotate
     */
    private void doeRotate(int rotate) {
        int hok = rotate * Integer.signum(rotate) - 1;
        boolean klokmee = Integer.signum(rotate) == 1;
        bord.getHok(hok).draai(klokmee);
    }

    /**
     * Kicks the given client
     *
     * @param client
     */
    public void kickClient(Client client) {
        clients.remove(client);
        this.broadcast(ProtocolEndpoint.BCST_GAMEOVER);
        for (Client c : this.getClients())
            c.setSpel(null);
    }

    private void speel() {
        Client aanDeBeurt = clients.get(zetIsAan);
        aanDeBeurt.canMove = true;
        broadcast(ProtocolEndpoint.BCST_TURN, aanDeBeurt.getNaam());
        int zet[] = aanDeBeurt.doeZet(bord);
        bord.doeMove(aanDeBeurt.getVeld(), zet[0]);
        if (!bord.heeftWinnaar())
            bord.doeRotate(zet[1]);
        if (++zetIsAan >= clients.size())
            zetIsAan = 0;
    }

    public void broadcast(String cmd, String... args) {
        for (Client c : clients)
            c.HANDLER.addMessage(cmd, args);
    }

    public boolean zetIsAanClient(Client client) {
        return clients.get(zetIsAan) == client;
    }

    public boolean isOver() {
        int alleKnikkers = 0;
        for (Client c : clients)
            alleKnikkers += c.aantalKnikkers;
        return alleKnikkers == 0 || bord.heeftWinnaar();
    }

    private String[] getPlayerNames() {
        String[] toRet = new String[clients.size()];
        for (int i = 0; i < toRet.length; i++)
            toRet[i] = clients.get(i).getNaam();

        return toRet;
    }

    /**
     * Starts the game.
     */
    public void start() {
        this.new Runner().start();
    }

    private class Runner extends Thread {

        @Override
        public void run() {
            int aantalKnikkers = clients.size() == 2 ? 40 : 20;
            for (int i = 0; i < clients.size(); i++) {
                Client c = clients.get(i);
                c.aantalKnikkers = aantalKnikkers;
                c.setVeld(Veld.byIndex(i));
            }

            broadcast(ProtocolEndpoint.BCST_STARTGAME, getPlayerNames());

            while (!isOver())
                speel();

            if (bord.heeftWinnaar()) {
                Speler[] winnaars = bord.getWinnaars();
                String[] winString = new String[winnaars.length];
                for (int i = 0; i < winnaars.length; i++)
                    winString[i] = winnaars[i].getNaam();
                broadcast(ProtocolEndpoint.BCST_GAMEOVER, winString);
            }
        }
    }
}
