/* Generated by Together */
package pentagoxl.spel;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Observable;
import pentagoxl.Client;
import pentagoxl.ProtocolEndpoint;
import pentagoxl.server.Server;
import pentagoxl.server.ServerClient;

public class Spel extends Observable {

    private Bord bord;
    private List<Client> clients = new ArrayList<Client>(4);
    private int zetIsAan;
    private boolean iemandKicked = false;

    public Spel() {
        bord = new Bord();
        zetIsAan = 0;
        clients = new ArrayList<Client>();
    }

    /**
     * Returns the <tt>Bord</tt> of this Spel.
     *
     * @return
     */
    public Bord getBord() {
        return bord;
    }

    /**
     * Returns a list of clients connec
     *
     * @return
     */
    public List<Client> getClients() {
        return clients;
    }

    public void addClient(Client client) {
        this.clients.add(client);
    }

    public void doeMove(int plek) {
        Client aanDeBeurt = clients.get(zetIsAan);
        aanDeBeurt.canMove = false;
        bord.doeMove(aanDeBeurt.getVeld(), plek);
        aanDeBeurt.aantalKnikkers -= 1;
        aanDeBeurt.canRotate = true;
        if (isOver()) {
            broadCastWinnaars();
            removeSpelers();
        }
    }

    private void removeSpelers() {
        for (Client c : clients) {
            c.clientsInGame = 0;
            c.setSpel(null);
        }

    }

    /**
     * Rotates one of the fields. <BR /> The fields are numbered: <BR /><tt> 1 |
     * 2 | 3 <BR /> 4 | 5 | 6 <BR /> 7 | 8 | 9 <BR /></tt> Negativeness is used
     * to rotate CCW.
     *
     * @param rotate Field to rotate
     */
    public void doeRotate(int rotate) {
        Client aanDeBeurt = clients.get(zetIsAan);
        aanDeBeurt.canRotate = false;
        nextPlayer();
        int hok = rotate * Integer.signum(rotate) - 1;
        boolean klokmee = Integer.signum(rotate) == 1;
        bord.getHok(hok).draai(klokmee);
        if (!isOver())
            speel();
        else
            broadCastWinnaars();
    }

    /**
     * Kicks the given client
     *
     * @param client
     */
    public void kickClient(Client client) {
        clients.remove(client);
        client.setSpel(null);
        client.clientsInGame = 0;
        this.broadcast(ProtocolEndpoint.BCST_GAMEOVER, this.getPlayerNames());
        removeSpelers();
    }

    private void speel() {
        Client aanDeBeurt = clients.get(zetIsAan);
        aanDeBeurt.canMove = true;
        broadcast(ProtocolEndpoint.BCST_TURN, aanDeBeurt.getNaam());
    }

    public void broadcast(String cmd, String... args) {
        for (Client c : clients)
            c.HANDLER.addMessage(cmd, args);
    }

    public boolean zetIsAanClient(Client client) {
        return clients.get(zetIsAan) == client;
    }

    public boolean isOver() {
        int alleKnikkers = 0;
        for (Client c : clients)
            alleKnikkers += c.aantalKnikkers;
        return alleKnikkers == 0 || bord.heeftWinnaar() || iemandKicked;
    }

    private String[] getPlayerNames() {
        String[] toRet = new String[clients.size()];
        for (int i = 0; i < toRet.length; i++)
            toRet[i] = clients.get(i).getNaam();

        return toRet;
    }

    /**
     * Starts the game.
     */
    public void start() {
        this.new Runner().start();
    }

    public void chat(String naam, String string) {
        List<Client> toSend = new ArrayList<Client>(clients);
        toSend.retainAll(Server.getClientsWithCaps(ServerClient.CHAT));
        for (Client c : toSend)
            c.HANDLER.addMessage(ProtocolEndpoint.BCST_CHAT, naam, string);
    }

    private class Runner extends Thread {

        @Override
        public void run() {
            int aantalKnikkers = clients.size() == 2 ? 40 : 20;
            for (int i = 0; i < clients.size(); i++) {
                Client c = clients.get(i);
                c.aantalKnikkers = aantalKnikkers;
                c.setVeld(Veld.byIndex(i));
            }

            broadcast(ProtocolEndpoint.SRV_ACK);
            broadcast(ProtocolEndpoint.BCST_STARTGAME, getPlayerNames());


            speel();
        }
    }

    private void broadCastWinnaars() {
        Veld[] winVelden = bord.getWinnaars();
        List<Speler> winners = new ArrayList<Speler>();
        for (Veld v : winVelden)
            for (Speler s : clients)
                if (s.getVeld() == v)
                    winners.add(s);
        Speler[] winnaars = (iemandKicked ? clients : winners).toArray(new Speler[0]);
        String[] winString = new String[winnaars.length];
        if (bord.heeftWinnaar())
            for (int i = 0; i < winnaars.length; i++)
                winString[i] = winnaars[i].getNaam();
        broadcast(ProtocolEndpoint.BCST_GAMEOVER, winString);
    }

    private void nextPlayer() {
        zetIsAan += 1;
        zetIsAan %= clients.size();
    }
}
